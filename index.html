<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Face Stretcher</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      overflow: hidden;
      background: #0a0a1a;
      font-family: 'Press Start 2P', monospace;
    }

    canvas#c {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }

    /* ── Main UI overlay ────────────────────────────────────────────── */
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 14px 16px 10px;
      gap: 8px;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(10,10,26,0.85) 0%, rgba(10,10,26,0) 100%);
    }

    #title {
      font-size: clamp(10px, 2.5vw, 20px);
      color: #e52222;
      text-shadow: 2px 2px 0 #ffd700, 4px 4px 0 #8b0000;
      letter-spacing: 0.05em;
      user-select: none;
    }

    #instructions {
      font-size: clamp(6px, 1.2vw, 9px);
      color: #ffd700;
      opacity: 0.8;
      user-select: none;
    }

    #controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      pointer-events: auto;
      margin-top: 2px;
    }

    .btn {
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(7px, 1.3vw, 10px);
      padding: 8px 14px;
      background: #e52222;
      color: #ffd700;
      border: 2px solid #ffd700;
      cursor: pointer;
      outline: none;
      box-shadow: 3px 3px 0 #8b0000;
      transition: transform 0.08s, box-shadow 0.08s;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .btn:hover  { background: #ff3333; }
    .btn:active { transform: translate(2px, 2px); box-shadow: 1px 1px 0 #8b0000; }
    .btn:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      pointer-events: none;
      transform: none;
      box-shadow: 3px 3px 0 #8b0000;
    }

    #upload-label { background: #1a1a8e; box-shadow: 3px 3px 0 #00008b; }
    #upload-label:hover { background: #2222aa; }
    #file-input { display: none; }

    #placeholder-msg {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      color: #ffd700;
      font-size: clamp(8px, 1.5vw, 12px);
      line-height: 2;
      opacity: 0.5;
      text-shadow: 1px 1px 0 #8b6914;
      user-select: none;
    }

    /* ── Crop overlay ───────────────────────────────────────────────── */
    #crop-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 100;
      background: #0a0a1a;
      flex-direction: column;
      align-items: stretch;
    }

    #crop-overlay.active { display: flex; }

    #crop-canvas {
      flex: 1;
      display: block;
      cursor: crosshair;
      touch-action: none;
      min-height: 0; /* flex shrink fix */
    }

    #crop-ui {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px 16px 16px;
      pointer-events: none;
      background: linear-gradient(to top, rgba(10,10,26,0.95) 0%, rgba(10,10,26,0.6) 60%, rgba(10,10,26,0) 100%);
    }

    #crop-title {
      font-size: clamp(10px, 2.5vw, 18px);
      color: #e52222;
      text-shadow: 2px 2px 0 #ffd700, 4px 4px 0 #8b0000;
      user-select: none;
    }

    #crop-hint {
      font-size: clamp(6px, 1.1vw, 8px);
      color: #ffd700;
      opacity: 0.75;
      user-select: none;
    }

    #crop-controls {
      display: flex;
      gap: 12px;
      pointer-events: auto;
      margin-top: 4px;
    }

    #crop-confirm-btn { background: #1a7a1a; box-shadow: 3px 3px 0 #0a4a0a; border-color: #ffd700; }
    #crop-confirm-btn:hover { background: #22aa22; }

    #save-btn { background: #7a5a00; box-shadow: 3px 3px 0 #4a3600; }
    #save-btn:hover { background: #aa7a00; }
    #save-btn:not(:disabled) { border-color: #ffd700; }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<!-- Crop overlay — shown after file upload, before stretch mode -->
<div id="crop-overlay">
  <canvas id="crop-canvas"></canvas>
  <div id="crop-ui">
    <div id="crop-title">CROP YOUR PHOTO</div>
    <div id="crop-hint">DRAG TO SELECT · ENTER TO CONFIRM · ESC TO SKIP</div>
    <div id="crop-controls">
      <button class="btn" id="crop-confirm-btn">CONFIRM</button>
      <button class="btn" id="crop-cancel-btn">SKIP CROP</button>
    </div>
  </div>
</div>

<div id="ui">
  <div id="title">FACE STRETCHER</div>
  <div id="instructions">upload · crop · drag to stretch · undo/redo</div>
  <div id="controls">
    <label class="btn" id="upload-label" for="file-input">UPLOAD PHOTO</label>
    <input type="file" id="file-input" accept="image/*">
    <button class="btn" id="reset-btn">RESET</button>
    <button class="btn" id="undo-btn" disabled>UNDO</button>
    <button class="btn" id="redo-btn" disabled>REDO</button>
    <button class="btn" id="save-btn" disabled>SAVE PNG</button>
  </div>
</div>

<div id="placeholder-msg">
  ↑ UPLOAD A PHOTO<br>TO BEGIN
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ──────────────────────────────────────────────────────────────────────────────
// SECTION 1: TUNEABLE CONSTANTS
// ──────────────────────────────────────────────────────────────────────────────
const CONFIG = {
  // Geometry
  PLANE_HEIGHT:       3.8,    // world-space height of mesh (width set from image aspect)
  SEGMENTS_X:         60,     // subdivisions horizontally
  SEGMENTS_Y:         60,     // subdivisions vertically

  // Grabbing / Deformation
  GRAB_RADIUS:        0.55,   // world-space radius of influence
  FALLOFF_SHARPNESS:  3.0,    // power-curve exponent (higher = more local pull)
  MAX_DISPLACEMENT:   1.8,    // max distance a vertex can move from origin

  // Z-axis (depth) displacement — gives a subtle 3D bulge when pulling
  DRAG_Z_SCALE:       0.12,

  // Spring reset animation
  SPRING_STIFFNESS:   180,    // k — higher = snappier return
  SPRING_DAMPING:     22,     // c — 22 is slightly underdamped (one gentle wobble)
  SPRING_THRESHOLD:   0.0005, // stop simulation when max displacement < this
};

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 2: RENDERER / SCENE / CAMERA
// ──────────────────────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
// alpha:true enables transparent background for PNG export
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, preserveDrawingBuffer: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0a0a1a, 1); // opaque dark during normal rendering

const scene = new THREE.Scene();

// Orthographic camera gives a flat "face on screen" look — matches SM64 aesthetic
let camH = CONFIG.PLANE_HEIGHT * 1.08;
let camW = camH * (window.innerWidth / window.innerHeight);

const camera = new THREE.OrthographicCamera(
  -camW / 2,  camW / 2,
   camH / 2, -camH / 2,
  0.1, 100
);
camera.position.set(0, 0, 10);

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 3: GEOMETRY, MATERIAL, MESH
// ──────────────────────────────────────────────────────────────────────────────
const mat = new THREE.MeshBasicMaterial({
  map: null,
  side: THREE.DoubleSide,
  color: 0x333355, // visible placeholder tint before texture loads
});

// Initial plane (square); resized when image loads
let geo = new THREE.PlaneGeometry(
  CONFIG.PLANE_HEIGHT,
  CONFIG.PLANE_HEIGHT,
  CONFIG.SEGMENTS_X,
  CONFIG.SEGMENTS_Y
);
geo.attributes.position.usage = THREE.DynamicDrawUsage;

let mesh = new THREE.Mesh(geo, mat);
mesh.frustumCulled = false; // prevent culling when vertices deform outside bounds
scene.add(mesh);

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 4: VERTEX STATE ARRAYS
// ──────────────────────────────────────────────────────────────────────────────
let posAttr      = geo.attributes.position;
let vertexCount  = posAttr.count;
let originPos    = new Float32Array(posAttr.array);    // rest positions, never modified
let displacement = new Float32Array(vertexCount * 3);  // current offset from origin
let velocity     = new Float32Array(vertexCount * 3);  // spring velocity

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 5: RAYCASTING + DRAG STATE
// ──────────────────────────────────────────────────────────────────────────────
const raycaster = new THREE.Raycaster();

let isDragging           = false;
let grabPoint            = null;   // THREE.Vector3 — world position of last drag sample
let isDirty              = false;  // true when GPU sync is needed this frame
let hasDraggedThisGesture = false; // guard: prevents bare clicks from pushing undo entries

function getEventNDC(e) {
  const cx = e.touches ? e.touches[0].clientX : e.clientX;
  const cy = e.touches ? e.touches[0].clientY : e.clientY;
  return new THREE.Vector2(
     (cx / window.innerWidth)  * 2 - 1,
    -(cy / window.innerHeight) * 2 + 1
  );
}

function getHitPoint(ndc) {
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObject(mesh);
  return hits.length > 0 ? hits[0].point : null;
}

function applyDrag(hitPoint) {
  const dragDX = hitPoint.x - grabPoint.x;
  const dragDY = hitPoint.y - grabPoint.y;
  const dragDZ = hitPoint.z - grabPoint.z;
  grabPoint.copy(hitPoint);

  const r        = CONFIG.GRAB_RADIUS;
  const r2       = r * r;
  const sharpness = CONFIG.FALLOFF_SHARPNESS;
  const maxDisp  = CONFIG.MAX_DISPLACEMENT;
  const zScale   = CONFIG.DRAG_Z_SCALE;

  for (let i = 0; i < vertexCount; i++) {
    const i3 = i * 3;

    // Distance from ORIGINAL position — stable during deformation
    const ox = originPos[i3];
    const oy = originPos[i3 + 1];
    const dx = ox - hitPoint.x;
    const dy = oy - hitPoint.y;
    const dist2 = dx * dx + dy * dy;

    if (dist2 >= r2) continue;

    // Power-curve falloff: steep at center, zero at radius edge — "taffy feel"
    const t      = 1.0 - Math.sqrt(dist2) / r;
    const weight = Math.pow(t, sharpness);

    displacement[i3]     += dragDX * weight;
    displacement[i3 + 1] += dragDY * weight;
    displacement[i3 + 2] += (dragDZ * weight + Math.sqrt(dragDX*dragDX + dragDY*dragDY) * weight * zScale);

    // Clamp total displacement magnitude
    const mx = displacement[i3];
    const my = displacement[i3 + 1];
    const mz = displacement[i3 + 2];
    const mag = Math.sqrt(mx*mx + my*my + mz*mz);
    if (mag > maxDisp) {
      const s = maxDisp / mag;
      displacement[i3]     *= s;
      displacement[i3 + 1] *= s;
      displacement[i3 + 2] *= s;
    }
  }

  velocity.fill(0);
  isDirty = true;
  hasDraggedThisGesture = true;
}

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 6: SPRING RESET
// ──────────────────────────────────────────────────────────────────────────────
let isSpringActive = false;

function triggerReset() {
  if (isDragging) return;
  isSpringActive = true;
}

function updateSpring(dt) {
  if (!isSpringActive) return;

  const k = CONFIG.SPRING_STIFFNESS;
  const c = CONFIG.SPRING_DAMPING;
  let maxAbs = 0;
  const n = vertexCount * 3;

  for (let i = 0; i < n; i++) {
    const acc = -k * displacement[i] - c * velocity[i];
    velocity[i]     += acc * dt;
    displacement[i] += velocity[i] * dt;

    const abs = Math.abs(displacement[i]);
    if (abs > maxAbs) maxAbs = abs;
  }

  isDirty = true;

  if (maxAbs < CONFIG.SPRING_THRESHOLD) {
    isSpringActive = false;
    displacement.fill(0);
    velocity.fill(0);
  }
}

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 7: GPU SYNC + ANIMATION LOOP
// ──────────────────────────────────────────────────────────────────────────────
function syncPositionsToGPU() {
  for (let i = 0; i < vertexCount; i++) {
    const i3 = i * 3;
    posAttr.array[i3]     = originPos[i3]     + displacement[i3];
    posAttr.array[i3 + 1] = originPos[i3 + 1] + displacement[i3 + 1];
    posAttr.array[i3 + 2] = originPos[i3 + 2] + displacement[i3 + 2];
  }
  posAttr.needsUpdate = true;
}

let prevTime = performance.now();

function animate(nowMs) {
  requestAnimationFrame(animate);

  const dt = Math.min((nowMs - prevTime) / 1000, 1 / 30);
  prevTime = nowMs;

  updateSpring(dt);

  if (isDirty) {
    syncPositionsToGPU();
    isDirty = false;
  }

  renderer.render(scene, camera);
}

requestAnimationFrame(animate);

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 8: MESH REBUILD + TEXTURE PIPELINE
// ──────────────────────────────────────────────────────────────────────────────
function rebuildMesh(planeW, planeH) {
  scene.remove(mesh);
  geo.dispose();

  geo = new THREE.PlaneGeometry(planeW, planeH, CONFIG.SEGMENTS_X, CONFIG.SEGMENTS_Y);
  geo.attributes.position.usage = THREE.DynamicDrawUsage;

  mesh = new THREE.Mesh(geo, mat);
  mesh.frustumCulled = false;
  scene.add(mesh);

  posAttr      = geo.attributes.position;
  vertexCount  = posAttr.count;
  originPos    = new Float32Array(posAttr.array);
  displacement = new Float32Array(vertexCount * 3);
  velocity     = new Float32Array(vertexCount * 3);

  isDirty        = false;
  isSpringActive = false;
  isDragging     = false;
  grabPoint      = null;

  camH = planeH * 1.08;
  camW = camH * (window.innerWidth / window.innerHeight);
  camera.left   = -camW / 2;
  camera.right  =  camW / 2;
  camera.top    =  camH / 2;
  camera.bottom = -camH / 2;
  camera.updateProjectionMatrix();
}

// Shared texture loading pipeline — called from both crop-confirm and crop-cancel paths
function loadTextureFromURL(url) {
  new THREE.TextureLoader().load(url, (texture) => {
    const img     = texture.image;
    const planeH  = CONFIG.PLANE_HEIGHT;
    const planeW  = planeH * (img.naturalWidth / img.naturalHeight);

    rebuildMesh(planeW, planeH);

    if (mat.map) mat.map.dispose();
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    mat.map = texture;
    mat.color.set(0xffffff);
    mat.needsUpdate = true;

    document.getElementById('placeholder-msg').style.display = 'none';
    document.getElementById('save-btn').disabled = false;

    clearUndoRedo(); // new image invalidates all previous vertex history

    if (url.startsWith('blob:')) URL.revokeObjectURL(url);
  });
}

// File input — load raw image, open crop overlay
const fileInput = document.getElementById('file-input');

fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  fileInput.value = ''; // allow same file re-upload

  const rawURL = URL.createObjectURL(file);
  const img    = new Image();
  img.onload   = () => {
    cropSourceImage = img;
    cropObjectURL   = rawURL;
    openCropOverlay();
  };
  img.src = rawURL;
});

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 8.5: CROP OVERLAY
// ──────────────────────────────────────────────────────────────────────────────
const cropOverlay    = document.getElementById('crop-overlay');
const cropCanvas     = document.getElementById('crop-canvas');
const cropCtx        = cropCanvas.getContext('2d');
const cropConfirmBtn = document.getElementById('crop-confirm-btn');
const cropCancelBtn  = document.getElementById('crop-cancel-btn');

let cropSourceImage = null;   // HTMLImageElement of full uploaded image
let cropObjectURL   = null;   // blob: URL — revoked once no longer needed
let cropDragging    = false;
let cropRect        = { x: 0, y: 0, w: 0, h: 0 }; // selection in canvas CSS pixels
let cropStartX      = 0;
let cropStartY      = 0;
let cropAntOffset   = 0;      // marching-ants animation offset (incremented per frame)
let cropRafId       = null;

function openCropOverlay() {
  cropOverlay.classList.add('active');
  requestAnimationFrame(() => {
    const rect        = cropCanvas.getBoundingClientRect();
    cropCanvas.width  = Math.floor(rect.width);
    cropCanvas.height = Math.floor(rect.height);
    cropRect          = computeLetterboxRect(); // default selection = full image
    cropAntOffset     = 0;
    cropRafId         = requestAnimationFrame(animateCropAnts);
  });
}

function closeCropOverlay() {
  if (cropRafId !== null) { cancelAnimationFrame(cropRafId); cropRafId = null; }
  cropOverlay.classList.remove('active');
  cropDragging    = false;
  cropSourceImage = null;
}

// Returns the rect (canvas px) that the image occupies when letterboxed inside the canvas
function computeLetterboxRect() {
  const cw = cropCanvas.width,  ch = cropCanvas.height;
  const iw = cropSourceImage.naturalWidth, ih = cropSourceImage.naturalHeight;
  const scale = Math.min(cw / iw, ch / ih);
  const dw = iw * scale, dh = ih * scale;
  return { x: (cw - dw) / 2, y: (ch - dh) / 2, w: dw, h: dh };
}

// Normalize crop rect so x,y is always top-left corner
function normalizeCropRect() {
  if (cropRect.w < 0) { cropRect.x += cropRect.w; cropRect.w = -cropRect.w; }
  if (cropRect.h < 0) { cropRect.y += cropRect.h; cropRect.h = -cropRect.h; }
}

function drawCropFrame() {
  const cw  = cropCanvas.width;
  const ch  = cropCanvas.height;
  const img = cropSourceImage;
  if (!img) return;

  const lb = computeLetterboxRect();

  cropCtx.clearRect(0, 0, cw, ch);

  // ── Draw full image, dimmed
  cropCtx.globalAlpha = 0.42;
  cropCtx.drawImage(img, lb.x, lb.y, lb.w, lb.h);
  cropCtx.globalAlpha = 1.0;

  // ── Determine normalized selection
  const selX = cropRect.w >= 0 ? cropRect.x : cropRect.x + cropRect.w;
  const selY = cropRect.h >= 0 ? cropRect.y : cropRect.y + cropRect.h;
  const selW = Math.abs(cropRect.w);
  const selH = Math.abs(cropRect.h);

  if (selW > 2 && selH > 2) {
    // ── Draw selected region at full brightness
    cropCtx.save();
    cropCtx.beginPath();
    cropCtx.rect(selX, selY, selW, selH);
    cropCtx.clip();
    cropCtx.drawImage(img, lb.x, lb.y, lb.w, lb.h);
    cropCtx.restore();

    // ── Marching-ants border — gold pass
    cropCtx.save();
    cropCtx.strokeStyle  = '#ffd700';
    cropCtx.lineWidth    = 2;
    cropCtx.setLineDash([8, 8]);
    cropCtx.lineDashOffset = -cropAntOffset;
    cropCtx.strokeRect(selX, selY, selW, selH);

    // ── Marching-ants border — white offset pass (contrast on dark images)
    cropCtx.strokeStyle  = 'rgba(255,255,255,0.55)';
    cropCtx.lineDashOffset = -cropAntOffset + 8;
    cropCtx.strokeRect(selX, selY, selW, selH);
    cropCtx.restore();

    // ── Rule-of-thirds grid
    cropCtx.save();
    cropCtx.strokeStyle = 'rgba(255,215,0,0.2)';
    cropCtx.lineWidth   = 1;
    cropCtx.setLineDash([]);
    for (let i = 1; i < 3; i++) {
      const gx = selX + (selW / 3) * i;
      const gy = selY + (selH / 3) * i;
      cropCtx.beginPath(); cropCtx.moveTo(gx, selY); cropCtx.lineTo(gx, selY + selH); cropCtx.stroke();
      cropCtx.beginPath(); cropCtx.moveTo(selX, gy); cropCtx.lineTo(selX + selW, gy); cropCtx.stroke();
    }
    cropCtx.restore();

    // ── Corner handles
    cropCtx.fillStyle = '#ffd700';
    const hs = 8;
    [[selX, selY], [selX + selW, selY], [selX, selY + selH], [selX + selW, selY + selH]]
      .forEach(([cx, cy]) => cropCtx.fillRect(cx - hs / 2, cy - hs / 2, hs, hs));
  }
}

function animateCropAnts() {
  cropAntOffset = (cropAntOffset + 0.25) % 16; // ~15px/s at 60fps
  drawCropFrame();
  cropRafId = requestAnimationFrame(animateCropAnts);
}

// Converts canvas-space crop rect to image-space pixel coordinates
function getClampedSelectionInImageSpace(lb) {
  normalizeCropRect();
  const scaleX = cropSourceImage.naturalWidth  / lb.w;
  const scaleY = cropSourceImage.naturalHeight / lb.h;

  // Clamp selection to within the letterbox rect
  const x1 = Math.max(cropRect.x,              lb.x);
  const y1 = Math.max(cropRect.y,              lb.y);
  const x2 = Math.min(cropRect.x + cropRect.w, lb.x + lb.w);
  const y2 = Math.min(cropRect.y + cropRect.h, lb.y + lb.h);

  return {
    srcX: Math.round((x1 - lb.x) * scaleX),
    srcY: Math.round((y1 - lb.y) * scaleY),
    w:    Math.round((x2 - x1)   * scaleX),
    h:    Math.round((y2 - y1)   * scaleY),
  };
}

// ── Crop pointer events (Pointer Events API — mouse + touch in one set) ───────
cropCanvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  cropCanvas.setPointerCapture(e.pointerId); // keeps events firing even outside element
  cropDragging = true;
  cropStartX   = e.offsetX;
  cropStartY   = e.offsetY;
  cropRect     = { x: cropStartX, y: cropStartY, w: 0, h: 0 };
});

cropCanvas.addEventListener('pointermove', (e) => {
  if (!cropDragging) return;
  cropRect.w = e.offsetX - cropStartX;
  cropRect.h = e.offsetY - cropStartY;
  // drawCropFrame is called by animateCropAnts — no explicit call needed
});

cropCanvas.addEventListener('pointerup',     () => { cropDragging = false; normalizeCropRect(); });
cropCanvas.addEventListener('pointercancel', () => { cropDragging = false; });

// ── Confirm: extract crop region → offscreen canvas → data URL → texture ──────
cropConfirmBtn.addEventListener('click', () => {
  normalizeCropRect();
  const lb  = computeLetterboxRect();
  const sel = getClampedSelectionInImageSpace(lb);

  // If selection is degenerate (too small / nothing drawn), fall back to full image
  if (sel.w < 4 || sel.h < 4) {
    const url = cropObjectURL; cropObjectURL = null;
    closeCropOverlay();
    loadTextureFromURL(url);
    return;
  }

  // Extract selected region at native image resolution
  const off = document.createElement('canvas');
  off.width  = sel.w;
  off.height = sel.h;
  off.getContext('2d').drawImage(
    cropSourceImage,
    sel.srcX, sel.srcY, sel.w, sel.h,
    0, 0, sel.w, sel.h
  );

  const dataURL = off.toDataURL('image/jpeg', 0.92);
  URL.revokeObjectURL(cropObjectURL); cropObjectURL = null;
  closeCropOverlay();
  loadTextureFromURL(dataURL);
});

// ── Cancel / Skip: use full uncropped image ───────────────────────────────────
cropCancelBtn.addEventListener('click', () => {
  const url = cropObjectURL; cropObjectURL = null;
  closeCropOverlay();
  loadTextureFromURL(url); // blob: URL revoked inside loadTextureFromURL after load
});

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 9: EVENT HANDLERS (MOUSE + TOUCH) — main stretch canvas
// ──────────────────────────────────────────────────────────────────────────────

// ── Mouse ─────────────────────────────────────────────────────────────────────
canvas.addEventListener('mousedown', (e) => {
  if (!mat.map) return;
  const hit = getHitPoint(getEventNDC(e));
  if (!hit) return;
  isDragging            = true;
  isSpringActive        = false;
  hasDraggedThisGesture = false;
  grabPoint             = hit.clone();
  capturePreDragSnapshot();
});

canvas.addEventListener('mousemove', (e) => {
  if (!isDragging || !grabPoint) return;
  const hit = getHitPoint(getEventNDC(e));
  if (!hit) return;
  applyDrag(hit);
});

canvas.addEventListener('mouseup', () => {
  if (isDragging && hasDraggedThisGesture) pushUndo();
  isDragging = false;
});

canvas.addEventListener('mouseleave', () => {
  if (isDragging && hasDraggedThisGesture) pushUndo();
  isDragging = false;
});

// ── Touch ─────────────────────────────────────────────────────────────────────
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (!mat.map) return;
  const hit = getHitPoint(getEventNDC(e));
  if (!hit) return;
  isDragging            = true;
  isSpringActive        = false;
  hasDraggedThisGesture = false;
  grabPoint             = hit.clone();
  capturePreDragSnapshot();
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!isDragging || !grabPoint) return;
  const hit = getHitPoint(getEventNDC(e));
  if (!hit) return;
  applyDrag(hit);
}, { passive: false });

canvas.addEventListener('touchend', () => {
  if (isDragging && hasDraggedThisGesture) pushUndo();
  isDragging = false;
});

canvas.addEventListener('touchcancel', () => {
  if (isDragging && hasDraggedThisGesture) pushUndo();
  isDragging = false;
});

// ── Reset button ──────────────────────────────────────────────────────────────
document.getElementById('reset-btn').addEventListener('click', () => {
  if (!mat.map) return;
  isDragging = false;
  grabPoint  = null;
  clearUndoRedo(); // hard reset wipes all history
  triggerReset();
});

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 10: RESIZE HANDLER
// ──────────────────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h);

  const aspect = w / h;
  camW = camH * aspect;
  camera.left  = -camW / 2;
  camera.right =  camW / 2;
  camera.updateProjectionMatrix();

  // Resize crop canvas if the overlay is currently open
  if (cropOverlay.classList.contains('active')) {
    requestAnimationFrame(() => {
      const r           = cropCanvas.getBoundingClientRect();
      cropCanvas.width  = Math.floor(r.width);
      cropCanvas.height = Math.floor(r.height);
      cropRect          = computeLetterboxRect(); // reset selection to full image
    });
  }
});

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 11: UNDO / REDO
// ──────────────────────────────────────────────────────────────────────────────
const UNDO_LIMIT = 50;
const undoStack  = []; // Float32Array[] — displacement snapshots (~44KB each)
const redoStack  = [];

const undoBtn = document.getElementById('undo-btn');
const redoBtn = document.getElementById('redo-btn');

function updateUndoRedoButtons() {
  undoBtn.disabled = undoStack.length === 0;
  redoBtn.disabled = redoStack.length === 0;
}

// Snapshot taken at gesture START (pre-drag state), pushed to stack at gesture END
let pendingUndoSnapshot = null;

function capturePreDragSnapshot() {
  pendingUndoSnapshot = displacement.slice();
}

function pushUndo() {
  if (!mat.map || !pendingUndoSnapshot) return;
  undoStack.push(pendingUndoSnapshot); // push the PRE-drag state
  pendingUndoSnapshot = null;
  if (undoStack.length > UNDO_LIMIT) undoStack.shift();
  redoStack.length = 0; // new gesture clears redo history (standard semantics)
  updateUndoRedoButtons();
}

function restoreSnapshot(snap) {
  isSpringActive        = false;
  isDragging            = false;
  hasDraggedThisGesture = false;
  grabPoint             = null;
  displacement.set(snap); // bulk copy — correct method for Float32Array
  velocity.fill(0);        // zero velocity to prevent phantom spring bounce
  isDirty = true;
}

function applyUndo() {
  if (!undoStack.length) return;
  redoStack.push(displacement.slice());
  restoreSnapshot(undoStack.pop());
  updateUndoRedoButtons();
}

function applyRedo() {
  if (!redoStack.length) return;
  undoStack.push(displacement.slice());
  if (undoStack.length > UNDO_LIMIT) undoStack.shift();
  restoreSnapshot(redoStack.pop());
  updateUndoRedoButtons();
}

function clearUndoRedo() {
  undoStack.length = 0;
  redoStack.length = 0;
  updateUndoRedoButtons();
}

undoBtn.addEventListener('click', applyUndo);
redoBtn.addEventListener('click', applyRedo);

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 12: KEYBOARD SHORTCUTS
// ──────────────────────────────────────────────────────────────────────────────
document.addEventListener('keydown', (e) => {
  // While crop overlay is open: Enter = confirm, Escape = skip
  if (cropOverlay.classList.contains('active')) {
    if (e.key === 'Enter')  cropConfirmBtn.click();
    if (e.key === 'Escape') cropCancelBtn.click();
    return; // don't process undo/redo shortcuts while crop is open
  }

  const mod = e.ctrlKey || e.metaKey;
  if (mod && e.key === 'z' && !e.shiftKey) { e.preventDefault(); applyUndo(); }
  if (mod && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); applyRedo(); }
});

// ──────────────────────────────────────────────────────────────────────────────
// SECTION 13: EXPORT / SAVE PNG
// ──────────────────────────────────────────────────────────────────────────────
document.getElementById('save-btn').addEventListener('click', () => {
  if (!mat.map) return;

  // 1. Render one frame with a transparent background
  renderer.setClearColor(0x000000, 0); // fully transparent clear
  renderer.render(scene, camera);
  renderer.setClearColor(0x0a0a1a, 1); // restore opaque dark for normal rendering

  // 2. Read all pixels from the WebGL canvas
  const dpr = renderer.getPixelRatio();
  const pw  = Math.round(window.innerWidth  * dpr);
  const ph  = Math.round(window.innerHeight * dpr);

  const gl     = renderer.getContext();
  const pixels = new Uint8Array(pw * ph * 4);
  gl.readPixels(0, 0, pw, ph, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

  // WebGL pixel origin is bottom-left; canvas 2D is top-left — flip vertically
  const flipped = new Uint8Array(pw * ph * 4);
  for (let row = 0; row < ph; row++) {
    const src  = (ph - 1 - row) * pw * 4;
    const dest = row * pw * 4;
    flipped.set(pixels.subarray(src, src + pw * 4), dest);
  }

  // 3. Find tight bounding box of non-transparent pixels
  let minX = pw, minY = ph, maxX = 0, maxY = 0;
  for (let y = 0; y < ph; y++) {
    for (let x = 0; x < pw; x++) {
      const a = flipped[(y * pw + x) * 4 + 3];
      if (a > 0) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
  }

  // Guard: nothing visible (no texture / fully transparent)
  if (maxX < minX || maxY < minY) return;

  const cropW = maxX - minX + 1;
  const cropH = maxY - minY + 1;

  // 4. Copy bounding-box region to an offscreen canvas
  const off    = document.createElement('canvas');
  off.width    = cropW;
  off.height   = cropH;
  const offCtx = off.getContext('2d');

  const imgData = offCtx.createImageData(cropW, cropH);
  for (let y = 0; y < cropH; y++) {
    for (let x = 0; x < cropW; x++) {
      const src  = ((minY + y) * pw + (minX + x)) * 4;
      const dest = (y * cropW + x) * 4;
      imgData.data[dest]     = flipped[src];
      imgData.data[dest + 1] = flipped[src + 1];
      imgData.data[dest + 2] = flipped[src + 2];
      imgData.data[dest + 3] = flipped[src + 3];
    }
  }
  offCtx.putImageData(imgData, 0, 0);

  // 5. Trigger download
  const link    = document.createElement('a');
  link.download = 'face-stretch.png';
  link.href     = off.toDataURL('image/png');
  link.click();
});
</script>
</body>
</html>
